Analysis
Reachable Numbers on a Wheel
Let us first define the concept of "reachable numbers" on a wheel. These are the set of numbers that can be displayed on a wheel by rotating it in increments of D
, starting from the initial number on the wheel as given in the input.

Example: Let us take N=6
 and D=4
, and we start from the number 1
 on the wheel. Then the reachable numbers are:

1+4=5
5+4=9⇒9−6=3
3+4=7⇒7−6=1
Which brings us back to the beginning. Thus, our set of reachable numbers is {1,3,5
}. Note here that we subtract 6
 from numbers >6
 because of the circular sequence of numbers on the wheel.

Test Set 1
We can try all combinations of reachable values on the wheels, check for each combination if it forms a palindrome and if it does, calculate the minimum number of operations required to form that combination.

Each wheel can have a maximum of N
 reachable values. For W
 wheels, the number of possible combinations that can be shown on the security key will be of the order of NW
. A combination can be generated by generating the possible values for each wheel. For a given index i
, we can start with Xi
, then incrementing the values in steps of D
. If the value overflows beyond N
, we circle back around to 1
 by subtracting N
, which then brings us to a value lying in [1⋯N]
. When we get to a value that we have previously encountered, we then have the complete set of values reachable for that index. In this way, we can generate all combinations by iterating through all possible reachable values for each index.

For each index, the set of reachable positions can be generated in O(N)
, and for W
 wheels, we can do this in O(N×W)
. Then, we can generate all combinations in O(NW)
.

For a particular combination A
, we can check if it is a palindrome by simply iterating over the array and verifying that Ai=AW−i+1
 for all i=1
 to W2
 in O(W)
.

If A
 is verified to be a palindrome, we can find the minimum cost of achieving the combination by summing over the minimum cost of converting each Xi
 to Ai
. For each i
, we can perform a process similar to the combination generation process by starting with Xi
 and simulating successive forward operations (that is keep adding D
) or by simulating successive backward operations (that is keep subtracting D
) till we reach Ai
. We take the minimum of the number of forward or backward operations as the minimum number of operations it will take to achieve the conversion. For each index i
, we can hence find out the cost in O(N)
. Therefore, the cost for all W
 wheels can be calculated in O(N×W)
 time.

Thus, the overall time complexity: O(NW×W×N)

Test Set 2
The above brute force of generating all possible combinations approach is not feasible to pass test set 2 constraints. Instead for each pair (Xi,XW−i+1)
 in the array X
 (for all i=1
 to W2
) that need to be equalized to make the array a palindrome, we calculate the minimum number of operations that can do so.

Before we move forward, we transpose the set of possible values for each wheel from [1⋯N]
 to [0⋯N−1]
. This will allow us to visualize the circular nature of operations as modulo N
. We do this by simply subtracting 1
 from all elements in X
.

With that, let us try to find the minimum operations to change Xi
 to XW−i+1
. Say we rotate the i
-th wheel in the positive direction and try to make it equal to Xj
. Let x
 be the number of operations it takes to do so. With operations being circular in nature, we get:

Xi+Dx≡Xj(modN)
⇒Xi+Dx+Ny=Xj
⇒Dx+Ny=Xj−Xi
The above equation is Linear Diophantine Equation. The greatest common divisor (GCD) of two numbers i
 and j
 can be written as GCDi,j
.

From the Extended Euclidean Algorithm, an LDE (Linear Diophantine Equation) ax+by=c
 has a solution only if c
 divides GCDa,b
. Thus, the above equation Dx+Ny=Xj−Xi
 will have a solution for x
 and y
 only if Xj−Xi
 is divisible by GCDD,N
. Thus, for any pair (Xi,XW−i+1)
, if XW−i+1−Xi
 is not divisible by GCDD,N
 the answer is IMPOSSIBLE.

Otherwise, we can use the Extended Euclidean Algorithm to solve for one possible solution for x
 and y
 in O(logmin(D,N))
. We need the minimal operations xmin
, which is (N+x)(modN)
. This is because a general solution for (x,y)
 will be of the form (x+kNGCDD,N,y−kDGCDD,N)
, where k
 is an arbitrary integer. From the above general form, we can see that the minimum number of operations xmin
 would be in the range [0,NGCDD,N−1]
 (if it is larger than that, we can simply subtract NGCDD,N
 from it to get a smaller value).

Hence, xmin=x(modNGCDD,N)
. Since x
 returned from the Extended Euclidean Algorithm can be negative, we add NGCDD,N
 and take modulo NGCDD,N
 again to get xmin=(NGCDD,N+x)(modNGCDD,N)
. Let us call this "forward direction xmin
" as xforward
.

Similarly, we can find the minimum number of operations if we rotate i
-th wheel in the backward direction. We get a similar equation in this case as well:

Xi−Dx≡Xj(modN)
⇒Xi−Dx+Ny=Xj
⇒Dx−Ny=Xi−Xj
We solve for xmin
 for this equation in a similar fashion using the Extended Euclidean Algorithm as the forward case. Let us call the xmin
 we get this time as xbackward
.

Thus, the overall minimum operations it takes to change Xi
 to Xj
 is min(xforward,xbackward)
. We add together the minimum costs for all such pairs (that is for all i=1
 to W/2
) to get the minimum cost to make the array a palindrome.

The overall time complexity: O(W×log(D))
.